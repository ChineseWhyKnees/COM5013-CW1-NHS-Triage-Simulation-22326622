"""
FILE: main.py
AUTHOR: 22326622
MODULE: COM5013 Algorithms & Data Structures

DESCRIPTION:
    The main entry point and integration hub for the NHS Triage Simulation.
    
    ARCHITECTURAL JUSTIFICATION
    Runtime Configuration:
    Overrides the default Python recursion limit via 'sys.setrecursionlimit'. 
    This is a specific fix for the 'RecursionError' encountered when 
    Merge-Sorting large datasets (N=10,000) generated by the LCG.
       
    System Diagnostics Suite:
    Includes a dedicated 'run_diagnostics' module to empirically prove 
    the Big O complexity claims made in the Development Report.
    - Verifies O(1) Queue performance vs O(N) Lists.
    - Verifies O(N log N) Sort scalability.
    - Verifies Hash Map collision handling.
       
    Structural Integration:
    Demonstrates the interaction between the LinkedQueue (Triage), 
    CircularQueue (Labs), and HashMap (Database) within a cohesive 
    CLI environment.
"""

# Imports all the custom classes (adhering to snake_case)
from patient_generator import patientdatagenerator
from patient_factory import patientfactory
from linked_structures import linkedqueue, linkedstack
from array_structures import circularqueue 
from hashmap import hashmap
from sorting_algorithms import merge_sort
import time
import sys

# --- RUNTIME CONFIGURATION ---
# Increase recursion depth for benchmark stress testing.
# Default is 1000. N=10,000 sorts require log2(N) depth which is safe, 
# but Python's overhead can trigger premature limits.
sys.setrecursionlimit(1000)

# --- COLOR CODES (ANSI Escape Sequences) ---
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# --- TELEMETRY UTILITIES ---
def loading_bar(task_name: str, duration: float):
    """Simulates a loading process with a visual progress bar."""
    print(f"{Colors.CYAN}{task_name:<30}{Colors.ENDC} [", end="", flush=True)
    steps = 20
    for _ in range(steps):
        time.sleep(duration / steps)
        print(f"{Colors.GREEN}={Colors.ENDC}", end="", flush=True)
    print("] DONE")

def print_header(text: str):
    print(f"\n{Colors.HEADER}{'='*60}{Colors.ENDC}")
    print(f"   {Colors.BOLD}{text}{Colors.ENDC}")
    print(f"{Colors.HEADER}{'='*60}{Colors.ENDC}")

def print_success(text: str):
    print(f" {Colors.GREEN}> SUCCESS:{Colors.ENDC} {text}")

def print_error(text: str):
    print(f" {Colors.FAIL}> ERROR:{Colors.ENDC} {text}")

def print_info(text: str):
    print(f" {Colors.BLUE}> INFO:{Colors.ENDC} {text}")

# --- LAYER 1: AUTHENTICATION ---
def system_login() -> bool:
    """Simulates a secure login prompt."""
    print_header("NHS TRIAGE SYSTEM v3.0")
    print("Authentication Required. (Try: SystemAdmin / 22326622)")
    
    attempts = 0
    while attempts < 3:
        user = input("Username: ")
        pwd = input("Password: ")
        
        if user == "SystemAdmin" and pwd == "22326622":
            print(f"\n{Colors.GREEN}ACCESS GRANTED.{Colors.ENDC} Initializing environment...")
            time.sleep(0.5)
            return True
        else:
            print(f"{Colors.FAIL}ACCESS DENIED.{Colors.ENDC} Invalid credentials.")
            attempts += 1
            
    print(f"{Colors.FAIL}Too many failed attempts. System Locking.{Colors.ENDC}")
    return False

# --- BENCHMARK SUITE ---
def run_diagnostics():
    """
    Executes the stress test suite to empirically verify Big O complexity.
    This serves as the 'White Box' testing framework required by LO3.
    """
    print_header("SYSTEM DIAGNOSTICS & BENCHMARKING")
    
    # TEST 1: SORTING COMPLEXITY
    print(f"\n{Colors.BOLD}[TEST 1] Verifying Merge Sort Time Complexity (O(n log n)){Colors.ENDC}")
    print(f"{'Dataset Size (N)':<20} {'Time (seconds)':<20}")
    print("-" * 40)
    
    sizes = [1000, 2000, 4000, 8000, 16000, 32000]
    test_gen = patientdatagenerator()
    factory = patientfactory(test_gen)
    
    for n in sizes:
        test_list = [factory.create_patient() for _ in range(n)]
        start_time = time.time()
        merge_sort(test_list) 
        end_time = time.time()
        print(f"{n:<20} {end_time - start_time:<20.4f}")

    print(f"\n{Colors.BOLD}[ANALYSIS]: Time approximately doubles as N doubles (with slight log factor).")
    print(f"            This confirms O(n log n) behavior.{Colors.ENDC}")

    # TEST 2: QUEUE PERFORMANCE
    print(f"\n{Colors.BOLD}[TEST 2] Verifying O(1) vs O(N) Queue Performance{Colors.ENDC}")
    print("Operation: Dequeue 10,000 items")
    print("-" * 40)
    print(f"{'Structure':<20} {'Time (seconds)':<20} {'Complexity':<20}")
    print("-" * 60)

    n_queue = 10000
    test_linked_queue = linkedqueue()
    test_list_queue = []
    
    for _ in range(n_queue):
        p = factory.create_patient()
        test_linked_queue.enqueue(p)
        test_list_queue.append(p)

    start_time = time.time()
    while not test_linked_queue.is_empty():
        test_linked_queue.dequeue()
    linked_time = time.time() - start_time

    start_time = time.time()
    while len(test_list_queue) > 0:
        test_list_queue.pop(0)
    list_time = time.time() - start_time

    print(f"{'LinkedQueue':<20} {linked_time:<20.4f} {Colors.GREEN}O(1) - Constant{Colors.ENDC}")
    print(f"{'Python List':<20} {list_time:<20.4f} {Colors.FAIL}O(N) - Linear{Colors.ENDC}")
    
    print(f"\n{Colors.BOLD}[ANALYSIS]: LinkedQueue demonstrates O(1) pointer efficiency.{Colors.ENDC}")

    # TEST 3: CIRCULAR QUEUE
    print(f"\n{Colors.BOLD}[TEST 3] Circular Queue Boundary Check{Colors.ENDC}")
    print("-" * 40)
    cq = circularqueue(5)
    print("Initializing Buffer (Size=5)... OK")
    
    print("Filling Buffer... ", end="")
    for i in range(5):
        cq.enqueue(f"P{i+1}")
    print(f"{cq.buffer} OK")
    
    print("Attempting Overflow Enqueue... ")
    cq.enqueue("P_Overflow")
    print_success("Overflow Handled Correctly.")

    print("\nDraining Buffer...")
    for _ in range(5):
        print(f"Dequeued: {cq.dequeue()}")
    
    print("Attempting Underflow Dequeue...")
    cq.dequeue()
    print_success("Underflow Handled Correctly.")

    # TEST 4: HASH MAP COLLISION HANDLING
    print(f"\n{Colors.BOLD}[TEST 4] Verifying Hash Map Collision Resolution (Separate Chaining){Colors.ENDC}")
    print("-" * 40)
    
    # 1. Force Collision: Capacity 10 means 15 items MUST collide
    test_map = hashmap(capacity=10) 
    print(f"Map Capacity: {test_map.capacity} buckets")
    print("Populating Map with 15 items (Guaranteed Overfill)...")
    
    for i in range(15):
        test_map.put(f"ID_{i}", f"Patient_{i}")
        
    # 2. Verify Retention
    print("Verifying Data Retention...")
    recovered = 0
    for i in range(15):
        if test_map.get(f"ID_{i}") == f"Patient_{i}":
            recovered += 1
            
    if recovered == 15:
        print(f"{Colors.GREEN}SUCCESS:{Colors.ENDC} All 15 items recovered despite capacity 10.")
        print("             Separate Chaining logic is active.")
    else:
        print(f"{Colors.FAIL}FAILURE:{Colors.ENDC} Data loss! Recovered {recovered}/15.")

    print_header("DIAGNOSTICS COMPLETE")
    input("\nPress Enter to return to main menu...")

# --- MAIN APPLICATION LOGIC ---
def main():
    # 0. Security Check
    if not system_login():
        return 

    # 1. System Initialization
    print_header("System Boot: Initializing Hospital Framework")
    loading_bar("Loading Patient Generator", 0.3)
    loading_bar("Initializing Database", 0.3)
    loading_bar("Calibrating Queues", 0.4)
    
    patient_data_tool = patientdatagenerator()
    main_patient_factory = patientfactory(generator=patient_data_tool)
    
    # Data Structures
    database = hashmap(capacity=100) 
    pharmacy_queue = linkedqueue()         
    blood_lab_buffer = circularqueue(max_size=5)
    
    # NEW: Admin Audit Log (Using LinkedStack directly in main)
    # This stores the history of admin actions (LIFO)
    admin_audit_log = linkedstack()
    admin_audit_log.push("System Booted")

    # 2. Generate Initial Data
    print(f"\n{Colors.BOLD}--- Simulating Initial Admissions (n=500) ---{Colors.ENDC}")
    all_patients = []
    for _ in range(500):
        new_patient = main_patient_factory.create_patient()
        database.put(new_patient.nhs_number, new_patient)
        all_patients.append(new_patient)

    all_patients = merge_sort(all_patients)
    print_success(f"Successfully admitted {len(all_patients)} patients.")
    print_info("Database Indexed via HashMap.")
        
         # 3. Interactive Menu
    while True:
        print_header("HOSPITAL ADMINISTRATION SYSTEM (HAS) - v3.0")
        print(f"   {Colors.CYAN}[1]{Colors.ENDC} Patient Search (NHS Number) & Hand-off")
        print(f"   {Colors.CYAN}[2]{Colors.ENDC} View Recent Admissions (Sorted by Priority)")
        print(f"   {Colors.CYAN}[3]{Colors.ENDC} System Statistics & Queue Status (Micro)")
        print(f"   {Colors.CYAN}[4]{Colors.ENDC} Run System Diagnostics (Stress Test)")
        print(f"   {Colors.CYAN}[5]{Colors.ENDC} View & Clear Admin Action Log (Stack Unwind)")
        print(f"   {Colors.CYAN}[6]{Colors.ENDC} Discharge and Refill (Macro)")
        print(f"   {Colors.CYAN}[7]{Colors.ENDC} Logout")
        print("-" * 60)
        
        choice = input(f"{Colors.BOLD}Select Option: {Colors.ENDC}")
    
        if choice == '1':
            target_id = input("\nEnter Patient NHS Number: ")
            record = database.get(target_id)
            
            # STACK OPERATION: Record this search
            admin_audit_log.push(f"Searched for {target_id}")
            
            if record:
                print(f"\n{Colors.GREEN}FOUND:{Colors.ENDC} {record.last_name}, {record.first_name}")
                print(f"Priority {record.priority} | Blood Type: {record.blood_type}") 
                current_status = record.get_current_status() # Capture status
                print(f"Status:   {current_status}")
                
                # --- LOGIC FIX: BLOCK DISCHARGED PATIENTS ---
                if "Discharged" in current_status:
                    print(f"\n{Colors.FAIL}ACTION DENIED:{Colors.ENDC} Patient has been discharged.")
                    print("To re-admit, please use the Refill cycle or generate a new record.")
                else:
                    # ONLY Show Action Menu if they are NOT discharged
                    print(f"\n{Colors.UNDERLINE}[ACTION MENU]{Colors.ENDC}")
                    print("1. Send to Pharmacy (LinkedQueue - O(1) FIFO)")
                    print("2. Send to Blood Lab (CircularQueue - Fixed Buffer)")
                    print("3. View History Log (LinkedStack - LIFO)")
                    action = input("Select Action: ")
                
                if action == '1':
                    record.update_status("Sent to Pharmacy")
                    pharmacy_queue.enqueue(record)
                    # STACK OPERATION: Push action
                    admin_audit_log.push(f"Sent {target_id} to Pharmacy")
                    print_success("Patient added to Pharmacy Line.")
                    
                elif action == '2':
                    print_info(f"Attempting to add to Blood Lab (Buffer: {blood_lab_buffer.get_size()}/5)...")
                    success = blood_lab_buffer.enqueue(record)
                    if success:
                        record.update_status("Sent to Blood Lab")
                        # STACK OPERATION: Push action
                        admin_audit_log.push(f"Sent {target_id} to Blood Lab")
                        print_success("Patient added to Lab Buffer.")
                    else:
                        record.update_status("Waitlisted for Lab")
                        admin_audit_log.push(f"Failed to send {target_id} to Lab (Full)")
                        print_error("Lab Buffer is FULL. Patient waitlisted.")
                        
                elif action == '3':
                    # Uses the stack internal to the PatientRecord (if implemented in patient_record.py)
                    # Note: We can also log this viewing event
                    admin_audit_log.push(f"Viewed History for {target_id}")
                    if record.history_log.is_empty():
                         print_info("No history log available for this patient.")
                    else:
                        print(f"Latest Patient Log: {record.history_log.peek()}")
                    
            else:
                print_error("Patient ID not found in database.")
                admin_audit_log.push(f"Search Failed: {target_id}")
            input("\nPress Enter to return...")

        elif choice == '2':
            print(f"\n{Colors.BOLD}--- Recent Admissions (High Priority) ---{Colors.ENDC}")
            admin_audit_log.push("Viewed Recent Admissions")
            for p in all_patients[:5]:
                print(f"ID: {p.nhs_number} | {Colors.FAIL}P:{p.priority}{Colors.ENDC} | {p.last_name}, {p.first_name}")
            input("\nPress Enter to return...")
            
        elif choice == '3':
            print(f"\n{Colors.BOLD}--- System Statistics ---{Colors.ENDC}")
            print(f"Database Capacity: {database.capacity} buckets")
            print(f"Total Records:     {len(all_patients)}")
            print(f"Pharmacy Queue:    {pharmacy_queue.get_size()} patients")
            print(f"Blood Lab Buffer:  {blood_lab_buffer.get_size()}/5 slots")
            print("-" * 30)
            
            # STACK OPERATION: Peek at the last admin action
            last_action = admin_audit_log.peek()
            print(f"Last Admin Action: {Colors.CYAN}{last_action}{Colors.ENDC}")
            
            if input("\nProcess Queues? (y/n): ").lower() == 'y':
                print("\nProcessing...")
                admin_audit_log.push("Processed Queues manually")
                if not pharmacy_queue.is_empty():
                    p = pharmacy_queue.dequeue()
                    p.update_status("Drugs Dispensed")
                    print_success(f"Pharmacy Served: {p.nhs_number}")
                else:
                    print_info("Pharmacy Queue is empty.")
                
                if not blood_lab_buffer.is_empty():
                    p = blood_lab_buffer.dequeue()
                    p.update_status("Blood Analyzed")
                    print_success(f"Lab Processed:   {p.nhs_number}")
                else:
                    print_info("Blood Lab Buffer is empty.")
                    
            input("\nPress Enter to return...")


        elif choice == '4':
            admin_audit_log.push("Ran Diagnostics")
            run_diagnostics()
            
        elif choice == '5':
            # STACK OPERATION: View with optional Clear/Restore
            print(f"\n{Colors.BOLD}--- Administrator Action Log (LIFO) ---{Colors.ENDC}")
            
            if admin_audit_log.is_empty():
                print_info("Log is empty.")
            else:
                print("Unwinding stack for display...")
                print("-" * 40)
                
                # 1. Unwind and Capture
                # We save items to a list so we can restore them if the user says 'No'
                temp_history = []
                count = 1
                
                while not admin_audit_log.is_empty():
                    action = admin_audit_log.pop()
                    print(f"{count}. {action}")
                    temp_history.append(action)
                    count += 1
                    
                print("-" * 40)
                
                # 2. The Toggle
                confirm = input(f"{Colors.WARNING}Permanently clear this log? (y/n): {Colors.ENDC}").lower()
                
                if confirm == 'y':
                    # Stack is already empty from the loop above, so we just confirm.
                    print_success("Audit Log cleared.")
                else:
                    # 3. Restore Logic
                    # We must push items back in REVERSE order (Bottom-up) to restore LIFO state.
                    print("Restoring history...", end="")
                    for action in reversed(temp_history):
                        admin_audit_log.push(action)
                    print(" Done.")
                    print_info("Log restored.")

            input("\nPress Enter to return...")
            
        elif choice == '6':
            print(f"\n{Colors.BOLD}--- Discharge and Refill Cycle ---{Colors.ENDC}")
            admin_audit_log.push("Executed Discharge & Refill")
            
            # 1. DISCHARGE: Process Pharmacy Queue (Simulate departures)
            print("Discharging Pharmacy... ", end="")
            discharged_count = 0
            while not pharmacy_queue.is_empty() and discharged_count < 3:
                p = pharmacy_queue.dequeue()
                p.update_status("Discharged Home")
                # This ensures they vanish from Option [2] "Recent Admissions"
                if p in all_patients:
                    all_patients.remove(p)
                print(f"[{p.nhs_number}]", end=" ")
                discharged_count += 1
            print(f"({discharged_count} patients left building)")
            
            # 2. PROCESS: Clear Blood Lab Buffer (Simulate analysis complete)
            print("Processing Lab Buffer...  ", end="")
            lab_count = 0
            while not blood_lab_buffer.is_empty():
                p = blood_lab_buffer.dequeue()
                p.update_status("Lab Results Analyzed")
                print(f"[{p.nhs_number}]", end=" ")
                lab_count += 1
            print(f"({lab_count} samples analyzed)")
            
            # 3. REFILL: Generate new incoming patients (Simulate arrivals)
            print("Admitting New Patients... ", end="")
            for _ in range(5):
                new_patient = main_patient_factory.create_patient()
                database.put(new_patient.nhs_number, new_patient)
                all_patients.append(new_patient)
                print(".", end="", flush=True)
            
            # Re-sort the master list so Option [2] stays correct
            all_patients = merge_sort(all_patients)
            print(" (5 new admissions processed)")
            
            input("\nCycle Complete. Press Enter...")

        elif choice == '7':
            print(f"\n{Colors.BOLD}Logging out...{Colors.ENDC}")
            break
        
        else:
            print_error("Invalid selection.")
            time.sleep(0.5)

if __name__ == "__main__":
    main()
